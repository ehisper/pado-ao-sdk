import { createDataItemSigner } from "@permaweb/aoconnect";
import { decrypt, encrypt, keygen, THRESHOLD_2_3 } from "./algorithm";
import { nodes } from "./processes/noderegistry";
import { getDataById, register as dataRegister } from "./processes/dataregistry";
import { getCompletedTasksById, getComputationPrice, submit } from "./processes/tasks";
import { getDataFromAR, submitDataToAR } from "./padoarweave";
import Arweave from "arweave";
import { transferAOCREDToTask } from "./processes/utils";
import { allData } from './processes/dataregistry';

interface nodeInfo {
  org_index: number,
  index: number,
  name: string,
  pk: string,
}

/**
* Get node infos
*
* @param n - How many nodes to select
* @param random - Whether randomly selected
* @returns The node infos
*/
const getNodeInfos = async (n: number, random: boolean = false): Promise<Array<nodeInfo>> => {
  let nodesres = await nodes();
  nodesres = JSON.parse(nodesres);
  if (nodesres.length < n) {
    throw `Insufficient number of nodes, expect ${n}, actual ${nodesres.length}`;
  }

  let selected_indices = Array.from({ length: nodesres.length }, (_, i) => i)
  if (random) {
    selected_indices.sort(function () { return 0.5 - Math.random(); });
  }

  let nodeInfos: Array<nodeInfo> = [];
  for (var i = 0; i < n; i++) {
    let node = nodesres[selected_indices[i]];
    nodeInfos.push({
      org_index: parseInt(node.index),
      index: parseInt(node.index),
      name: node.name,
      pk: node.publickey
    });
  }
  // console.log(nodeInfos);

  // it's ok, no matter sorted or not
  // nodeInfos.sort((a, b) => a.org_index - b.org_index);

  // re-index, do not care original index
  for (var i = 0; i < nodeInfos.length; i++) {
    nodeInfos[i].index = i + 1;
  }
  return nodeInfos;
}


export interface PriceInfo {
  price: string;
  symbol?: string;
}

/**
* Encrypt data and upload data
*
* @param data - plain data need to encrypt and upload
* @param dataTag - the data meta info
* @param priceInfo - The data price symbol and price
* @param wallet - The ar wallet
* @param arweave - The ar object and default is ar production
* @returns The uploaded encrypted data id
*/
export const uploadData = async (data: Uint8Array, dataTag: any, priceInfo: PriceInfo,
  wallet: any, arweave: Arweave = Arweave.init({})): Promise<string> => {
  if (data.length === 0) {
    throw new Error("The Data to be uploaded can not be empty");
  }

  // TODO: only support 2-3 at present
  var policy = {
    t: THRESHOLD_2_3.t,
    n: THRESHOLD_2_3.n,
    indices: [] as number[],
    names: [] as string[],
  };
  let nodeInfos = await getNodeInfos(policy.n, true);
  // console.log(nodeInfos);

  let nodesPublicKey = [] as string[];
  for (var i = 0; i < nodeInfos.length; i++) {
    policy.indices.push(nodeInfos[i].index);
    policy.names.push(nodeInfos[i].name);
    nodesPublicKey.push(nodeInfos[i].pk);
  }
  console.log(policy);

  const res = encrypt(nodesPublicKey, data, policy);
  // console.log(res);
  const transactionId = await submitDataToAR(arweave, res.enc_msg, wallet);

  const signer = createDataItemSigner(wallet);
  let exData = {
    policy: policy,
    nonce: res.nonce,
    transactionId: transactionId,
    encSks: res.enc_sks,
  };
  // console.log(exData);

  priceInfo.symbol = priceInfo.symbol || "AOCRED";
  const dataRes = await dataRegister(JSON.stringify(dataTag), JSON.stringify(priceInfo), JSON.stringify(exData), signer);
  // console.log('res.dataRes', dataRes);

  return dataRes;
}

/**
 * Generate key pair for encrypt/decrypt
 *
 * @returns The key-pair object
 */
export const generateKey = (): Promise<any> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(keygen());
    }, 1000);
  });
}


export const listData = () => {
  return  allData();
};

//TODO:
const taskType = "ZKLHEDataSharing";
const computeLimit = "9000000000000";
const memoryLimit = "512M";

/**
 * Submit a task to AO
 *
 * @param dataId - The data id
 * @param dataUserPk - The user's public key generated by keygen
 * @param wallet - The ar wallet
 * @returns The submited task id
 */
export const submitTask = async (dataId: string, dataUserPk: string, wallet: any): Promise<string> => {
  let encData = await getDataById(dataId);
  encData = JSON.parse(encData);
  // console.log(encData);
  const exData = JSON.parse(encData.data);
  const nodeNames = exData.policy.names;
  const priceObj = JSON.parse(encData.price);
  const symbol = priceObj.symbol;
  if(symbol!=='AOCRED'){
    throw new Error('Only support AOCRED now');
  }
  const dataPrice = priceObj.price;
  //get node price
  const nodePrice = await getComputationPrice();
  const totalPrice = Number(dataPrice)+Number(nodePrice)*nodeNames.length;
  // console.log(`dataPrice is:${dataPrice} and nodePrice is:${nodePrice},size of nodes is:${nodeNames.length},totalPrice is:${totalPrice}`);

  // console.log('exData.policy', exData.policy);
  // console.log('nodeNames', nodeNames);
  const signer = createDataItemSigner(wallet);
  try{
    await transferAOCREDToTask(totalPrice.toString(),signer);
  }catch (err){
    if(err==='Insufficient Balance!'){
      throw new Error('Insufficient Balance! Please ensure that your wallet balance is greater than '+totalPrice+' AOCRED');
    }else {
      throw err;
    }
  }

  let inputData = { dataId: dataId, consumerPk: dataUserPk };
  const taskId = await submit(taskType, dataId, JSON.stringify(inputData),
    computeLimit, memoryLimit, nodeNames, signer);
  return taskId;
};

const getCompletedTaskPromise = (taskId: string, timeout: number): Promise<string> => {
  return new Promise((resolve, reject) => {
    const start = performance.now();
    const tick = async () => {
      const timeGap = performance.now() - start;
      const taskStr = await getCompletedTasksById(taskId);
      const task = JSON.parse(taskStr);
      if (task.id) {
        resolve(taskStr);
      } else if (timeGap > timeout) {
        reject('timeout');
      } else {
        setTimeout(tick, 500);
      }
    };
    tick();
  });
};


/**
 * Get the result of the task
 * 
 * @param taskId The task id
 * @param dataUserSk - The user's secret key generated by keygen
 * @param arweave - The ar object and default is ar production
 * @param timeout Timeout in milliseconds (default: 10 seconds)
 * @returns The data
 */
export const getResult = async (taskId: string, dataUserSk: string,
  arweave: Arweave = Arweave.init({}), timeout: number = 10000) => {
  const taskStr = await getCompletedTaskPromise(taskId, timeout);
  const task = JSON.parse(taskStr);

  if (task.verificationError) {
    throw task.verificationError;
  }

  let dataId = (JSON.parse(task.inputData)).dataId;
  let encData = await getDataById(dataId);
  encData = JSON.parse(encData);
  let exData = JSON.parse(encData.data);

  // TODO: since only support THRESHOLD_2_3 at present, we choice the first t nodes
  let chosenIndices = [];
  let reencChosenSks = [];
  for (var i = 0; i < THRESHOLD_2_3.t; i++) {
    let index = exData.policy.indices[i];
    chosenIndices.push(index);

    let name = exData.policy.names[i];
    console.log("name=", name);
    const reencSksObj = JSON.parse(task.result[name]);
    reencChosenSks.push(reencSksObj.reenc_sk);
  }
  console.log("chosenIndices=", chosenIndices);
  // console.log("reencChosenSks=", reencChosenSks);

  //console.log("getResult ar encData=", encData);
  const encMsg = await getDataFromAR(arweave, exData.transactionId);
  console.log("getResult encMsg=", encMsg);
  const res = decrypt(reencChosenSks, dataUserSk, exData.nonce, encMsg, chosenIndices);
  return new Uint8Array(res.msg);
};



/**
 * Submit a task to AO and get the result. The combination of submitTask and getResult
 *
 * @param dataId - The data id
 * @param pk - The user's public key generated by keygen
 * @param sk - The user's secret key generated by keygen
 * @param wallet - The ar wallet
 * @param arweave - The ar object and default is ar production
 * @param timeout Timeout in milliseconds (default: 10 seconds)
 * @returns The data
 */
export const submitTaskAndGetResult = async (dataId: string, pk: string, sk: string, wallet: any,
  arweave: Arweave = Arweave.init({}), timeout: number = 10000) => {
  const taskId = await submitTask(dataId, pk, wallet);
  const result = await getResult(taskId, sk, arweave, timeout);
  return result;
}

